// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/raft.proto

/*
Package RaftProtocol is a generated protocol buffer package.

It is generated from these files:
	proto/raft.proto

It has these top-level messages:
	Error
	Server
	SimpleConfiguration
	Configuration
	Entry
	RequestVote
	AppendEntries
	InstallSnapshot
*/
package RaftProtocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// *
// Identifies which RPC is being executed.
type OpCode int32

const (
	// Keep these numbers dense.
	OpCode_REQUEST_VOTE     OpCode = 0
	OpCode_APPEND_ENTRIES   OpCode = 1
	OpCode_INSTALL_SNAPSHOT OpCode = 2
)

var OpCode_name = map[int32]string{
	0: "REQUEST_VOTE",
	1: "APPEND_ENTRIES",
	2: "INSTALL_SNAPSHOT",
}
var OpCode_value = map[string]int32{
	"REQUEST_VOTE":     0,
	"APPEND_ENTRIES":   1,
	"INSTALL_SNAPSHOT": 2,
}

func (x OpCode) String() string {
	return proto.EnumName(OpCode_name, int32(x))
}
func (OpCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// *
// The type of payload stored in a log entry.
type EntryType int32

const (
	// *
	// This must be the first value in the enum and is never assigned
	// explicitly. If new values are added, old code will see them as set
	// and equal to this value (though they will still serialize to the
	// correct value).
	EntryType_UNKNOWN EntryType = 0
	// *
	// Stores a 'Configuration', to be used internally by the consensus module.
	EntryType_CONFIGURATION EntryType = 1
	// *
	// Stores a command to be processed by the state machine.
	EntryType_DATA EntryType = 2
	// *
	// No op.
	EntryType_NOOP EntryType = 3
)

var EntryType_name = map[int32]string{
	0: "UNKNOWN",
	1: "CONFIGURATION",
	2: "DATA",
	3: "NOOP",
}
var EntryType_value = map[string]int32{
	"UNKNOWN":       0,
	"CONFIGURATION": 1,
	"DATA":          2,
	"NOOP":          3,
}

func (x EntryType) String() string {
	return proto.EnumName(EntryType_name, int32(x))
}
func (EntryType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// *
// The type of "service-specific error" replies that this service returns.
type Error struct {
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// *
// A server in a configuration.
type Server struct {
	// *
	// The ID of the server.
	ServerId uint64 `protobuf:"varint,1,opt,name=server_id,json=serverId" json:"server_id,omitempty"`
	// *
	// The network address(es) of the server (comma-delimited).
	Addresses string `protobuf:"bytes,2,opt,name=addresses" json:"addresses,omitempty"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Server) GetServerId() uint64 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *Server) GetAddresses() string {
	if m != nil {
		return m.Addresses
	}
	return ""
}

// *
// A stable configuraton, in which a simple majority constitutes a quorum.
type SimpleConfiguration struct {
	Servers []*Server `protobuf:"bytes,1,rep,name=servers" json:"servers,omitempty"`
}

func (m *SimpleConfiguration) Reset()                    { *m = SimpleConfiguration{} }
func (m *SimpleConfiguration) String() string            { return proto.CompactTextString(m) }
func (*SimpleConfiguration) ProtoMessage()               {}
func (*SimpleConfiguration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SimpleConfiguration) GetServers() []*Server {
	if m != nil {
		return m.Servers
	}
	return nil
}

// *
// A stable or transitional configuration.
type Configuration struct {
	// *
	// The servers in a stable configuration, or the old servers in a
	// transitional configuration.
	PrevConfiguration *SimpleConfiguration `protobuf:"bytes,1,opt,name=prev_configuration,json=prevConfiguration" json:"prev_configuration,omitempty"`
	// *
	// Not present in a stable configuration, or the new servers in a
	// transitional configuration.
	NextConfiguration *SimpleConfiguration `protobuf:"bytes,2,opt,name=next_configuration,json=nextConfiguration" json:"next_configuration,omitempty"`
}

func (m *Configuration) Reset()                    { *m = Configuration{} }
func (m *Configuration) String() string            { return proto.CompactTextString(m) }
func (*Configuration) ProtoMessage()               {}
func (*Configuration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Configuration) GetPrevConfiguration() *SimpleConfiguration {
	if m != nil {
		return m.PrevConfiguration
	}
	return nil
}

func (m *Configuration) GetNextConfiguration() *SimpleConfiguration {
	if m != nil {
		return m.NextConfiguration
	}
	return nil
}

// *
// Log entry.
type Entry struct {
	// *
	// The term in which the entry was first created.
	Term uint64 `protobuf:"varint,1,opt,name=term" json:"term,omitempty"`
	// *
	// The index for the entry. It's truly (if you receive an entry
	// over the network, you shouldn't rely on this). It's used for followers
	// to check that they've got the entry at the right index and also used
	// internally in some storage backends such as SegmentedLog.
	Index uint64 `protobuf:"varint,5,opt,name=index" json:"index,omitempty"`
	// *
	// Roughly the number of nanoseconds the cluster has had a leader. This
	// gets passed onto state machines, where it's used for cleaning up client
	// sessions. See ClusterClock for more details.
	ClusterTime uint64 `protobuf:"varint,6,opt,name=cluster_time,json=clusterTime" json:"cluster_time,omitempty"`
	// *
	// See EntryType.
	Type EntryType `protobuf:"varint,2,opt,name=type,enum=RaftProtocol.EntryType" json:"type,omitempty"`
	// *
	// A Configuration to be used internally by the consensus module.
	Configuration *Configuration `protobuf:"bytes,3,opt,name=configuration" json:"configuration,omitempty"`
	// *
	// A command to be processed by the state machine.
	Data []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Entry) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Entry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Entry) GetClusterTime() uint64 {
	if m != nil {
		return m.ClusterTime
	}
	return 0
}

func (m *Entry) GetType() EntryType {
	if m != nil {
		return m.Type
	}
	return EntryType_UNKNOWN
}

func (m *Entry) GetConfiguration() *Configuration {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *Entry) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// RequestVote RPC: ask a server for its vote in an election and/or get a
// server's log information.
type RequestVote struct {
}

func (m *RequestVote) Reset()                    { *m = RequestVote{} }
func (m *RequestVote) String() string            { return proto.CompactTextString(m) }
func (*RequestVote) ProtoMessage()               {}
func (*RequestVote) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type RequestVote_Request struct {
	// *
	// ID of the caller, so that if it re-requests the vote from the
	// callee, the server will respond granted.
	ServerId uint64 `protobuf:"varint,1,opt,name=server_id,json=serverId" json:"server_id,omitempty"`
	// *
	// Caller's term.
	Term uint64 `protobuf:"varint,2,opt,name=term" json:"term,omitempty"`
	// *
	// Term of last entry in caller's log.
	// Used to compare log completeness.
	LastLogTerm uint64 `protobuf:"varint,3,opt,name=last_log_term,json=lastLogTerm" json:"last_log_term,omitempty"`
	// *
	// ID of last entry in caller's log.
	// Used to compare log completeness.
	LastLogIndex uint64 `protobuf:"varint,4,opt,name=last_log_index,json=lastLogIndex" json:"last_log_index,omitempty"`
}

func (m *RequestVote_Request) Reset()                    { *m = RequestVote_Request{} }
func (m *RequestVote_Request) String() string            { return proto.CompactTextString(m) }
func (*RequestVote_Request) ProtoMessage()               {}
func (*RequestVote_Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

func (m *RequestVote_Request) GetServerId() uint64 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *RequestVote_Request) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestVote_Request) GetLastLogTerm() uint64 {
	if m != nil {
		return m.LastLogTerm
	}
	return 0
}

func (m *RequestVote_Request) GetLastLogIndex() uint64 {
	if m != nil {
		return m.LastLogIndex
	}
	return 0
}

type RequestVote_Response struct {
	// *
	// Callee's term, for caller to update itself.
	Term uint64 `protobuf:"varint,1,opt,name=term" json:"term,omitempty"`
	// *
	// True if the follower granted the candidate its vote, false
	// otherwise.
	Granted bool `protobuf:"varint,2,opt,name=granted" json:"granted,omitempty"`
	// *
	// Set to true if the caller's log is as up-to-date as the recipient's.
	// This isn't presently used, but it's easy to return and might be
	// useful later. In the Pre-Vote extension to Raft described in Section
	// 9.6 "Preventing disruptions when a server rejoins the cluster" of
	// Diego Ongaro's PhD dissertation, a server needs to know if its log
	// is sufficient to get elected before actually starting an election.
	LogOk bool `protobuf:"varint,3,opt,name=log_ok,json=logOk" json:"log_ok,omitempty"`
}

func (m *RequestVote_Response) Reset()                    { *m = RequestVote_Response{} }
func (m *RequestVote_Response) String() string            { return proto.CompactTextString(m) }
func (*RequestVote_Response) ProtoMessage()               {}
func (*RequestVote_Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 1} }

func (m *RequestVote_Response) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestVote_Response) GetGranted() bool {
	if m != nil {
		return m.Granted
	}
	return false
}

func (m *RequestVote_Response) GetLogOk() bool {
	if m != nil {
		return m.LogOk
	}
	return false
}

// *
// AppendEntries RPC: replicate log entries to a follower.
type AppendEntries struct {
}

func (m *AppendEntries) Reset()                    { *m = AppendEntries{} }
func (m *AppendEntries) String() string            { return proto.CompactTextString(m) }
func (*AppendEntries) ProtoMessage()               {}
func (*AppendEntries) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type AppendEntries_Request struct {
	// *
	// ID of leader (caller), so the follower can redirect clients.
	ServerId uint64 `protobuf:"varint,1,opt,name=server_id,json=serverId" json:"server_id,omitempty"`
	// *
	// Caller's term.
	Term uint64 `protobuf:"varint,2,opt,name=term" json:"term,omitempty"`
	// *
	// ID of entry preceding entries, or ID of last log entry for
	// heartbeat.
	PrevLogIndex uint64 `protobuf:"varint,3,opt,name=prev_log_index,json=prevLogIndex" json:"prev_log_index,omitempty"`
	// *
	// Term of prev_log_index.
	PrevLogTerm uint64 `protobuf:"varint,4,opt,name=prev_log_term,json=prevLogTerm" json:"prev_log_term,omitempty"`
	// *
	// Log entries for follower to store, or empty for heartbeat.
	Entries []*Entry `protobuf:"bytes,5,rep,name=entries" json:"entries,omitempty"`
	// *
	// Last committed entry that the follower has, so the follower can
	// advance its state machine.
	CommitIndex uint64 `protobuf:"varint,6,opt,name=commit_index,json=commitIndex" json:"commit_index,omitempty"`
}

func (m *AppendEntries_Request) Reset()                    { *m = AppendEntries_Request{} }
func (m *AppendEntries_Request) String() string            { return proto.CompactTextString(m) }
func (*AppendEntries_Request) ProtoMessage()               {}
func (*AppendEntries_Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

func (m *AppendEntries_Request) GetServerId() uint64 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *AppendEntries_Request) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *AppendEntries_Request) GetPrevLogIndex() uint64 {
	if m != nil {
		return m.PrevLogIndex
	}
	return 0
}

func (m *AppendEntries_Request) GetPrevLogTerm() uint64 {
	if m != nil {
		return m.PrevLogTerm
	}
	return 0
}

func (m *AppendEntries_Request) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *AppendEntries_Request) GetCommitIndex() uint64 {
	if m != nil {
		return m.CommitIndex
	}
	return 0
}

type AppendEntries_Response struct {
	// *
	// Callee's term, for the caller to update itself.
	Term uint64 `protobuf:"varint,1,opt,name=term" json:"term,omitempty"`
	// *
	// True if new entries were added to the log.
	Success bool `protobuf:"varint,2,opt,name=success" json:"success,omitempty"`
	// *
	// The recipient's last log index (after it's applied this RPC's
	// changes to the log). This is used to speed up finding the correct
	// value for nextIndex with a follower that is far behind the leader.
	LastLogIndex uint64 `protobuf:"varint,3,opt,name=last_log_index,json=lastLogIndex" json:"last_log_index,omitempty"`
	// *
	// Sent back to inform leader of what code the recipient is running.
	ServerCapabilities *AppendEntries_Response_ServerCapabilities `protobuf:"bytes,4,opt,name=server_capabilities,json=serverCapabilities" json:"server_capabilities,omitempty"`
}

func (m *AppendEntries_Response) Reset()                    { *m = AppendEntries_Response{} }
func (m *AppendEntries_Response) String() string            { return proto.CompactTextString(m) }
func (*AppendEntries_Response) ProtoMessage()               {}
func (*AppendEntries_Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 1} }

func (m *AppendEntries_Response) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *AppendEntries_Response) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *AppendEntries_Response) GetLastLogIndex() uint64 {
	if m != nil {
		return m.LastLogIndex
	}
	return 0
}

func (m *AppendEntries_Response) GetServerCapabilities() *AppendEntries_Response_ServerCapabilities {
	if m != nil {
		return m.ServerCapabilities
	}
	return nil
}

type AppendEntries_Response_ServerCapabilities struct {
	// *
	// The server's state machine can behave like all state machine
	// versions between min_supported_state_machine_version and
	// max_supported_state_machine_version, inclusive.
	MinSupportedStateMachineVersion uint32 `protobuf:"varint,1,opt,name=min_supported_state_machine_version,json=minSupportedStateMachineVersion" json:"min_supported_state_machine_version,omitempty"`
	// *
	// The server's state machine can behave like all state machine
	// versions between min_supported_state_machine_version and
	// max_supported_state_machine_version, inclusive.
	MaxSupportedStateMachineVersion uint32 `protobuf:"varint,2,opt,name=max_supported_state_machine_version,json=maxSupportedStateMachineVersion" json:"max_supported_state_machine_version,omitempty"`
}

func (m *AppendEntries_Response_ServerCapabilities) Reset() {
	*m = AppendEntries_Response_ServerCapabilities{}
}
func (m *AppendEntries_Response_ServerCapabilities) String() string { return proto.CompactTextString(m) }
func (*AppendEntries_Response_ServerCapabilities) ProtoMessage()    {}
func (*AppendEntries_Response_ServerCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 1, 0}
}

func (m *AppendEntries_Response_ServerCapabilities) GetMinSupportedStateMachineVersion() uint32 {
	if m != nil {
		return m.MinSupportedStateMachineVersion
	}
	return 0
}

func (m *AppendEntries_Response_ServerCapabilities) GetMaxSupportedStateMachineVersion() uint32 {
	if m != nil {
		return m.MaxSupportedStateMachineVersion
	}
	return 0
}

// *
// InstallSnapshot RPC: replicate part of a snapshot file to a follower.
type InstallSnapshot struct {
}

func (m *InstallSnapshot) Reset()                    { *m = InstallSnapshot{} }
func (m *InstallSnapshot) String() string            { return proto.CompactTextString(m) }
func (*InstallSnapshot) ProtoMessage()               {}
func (*InstallSnapshot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type InstallSnapshot_Request struct {
	// *
	// ID of leader (caller), so the follower can redirect clients.
	ServerId uint64 `protobuf:"varint,1,opt,name=server_id,json=serverId" json:"server_id,omitempty"`
	// *
	// Caller's term.
	Term uint64 `protobuf:"varint,3,opt,name=term" json:"term,omitempty"`
	// *
	// The snapshot covers log entries in the range [1, lastSnapshotIndex].
	// While this information can be found in the snapshot itself, a
	// follower may want to know sooner (for example, to name the snapshot
	// file or to assert that it's not overwriting something more
	// important).
	LastSnapshotIndex uint64 `protobuf:"varint,4,opt,name=last_snapshot_index,json=lastSnapshotIndex" json:"last_snapshot_index,omitempty"`
	// *
	// The byte offset where 'data' belongs in the file. Followers can
	// expect this to grow without gaps, but they should use this to drop
	// duplicate request messages.
	ByteOffset uint64 `protobuf:"varint,5,opt,name=byte_offset,json=byteOffset" json:"byte_offset,omitempty"`
	// *
	// Raw bytes of the snapshot file. This should be big enough to achieve
	// reasonable throughput without having to pipeline RPCs.
	Data []byte `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// *
	// Set to true if this is the last chunk of the file and the follower
	// should now load the contents; false otherwise.
	Done bool `protobuf:"varint,7,opt,name=done" json:"done,omitempty"`
	// *
	// Explains which version of this RPC the leader (caller) supports.
	// - Servers speaking version 1 of this RPC (corresponding to LogCabin
	//   release v1.0.0 and up to a few weeks after) did not set this
	//   field.
	// - Version 2 introduced the bytes_stored field in responses. Before
	//   this, leaders assumed that InstallSnapshot always succeeded if the
	//   term matched.
	Version uint32 `protobuf:"varint,8,opt,name=version" json:"version,omitempty"`
}

func (m *InstallSnapshot_Request) Reset()                    { *m = InstallSnapshot_Request{} }
func (m *InstallSnapshot_Request) String() string            { return proto.CompactTextString(m) }
func (*InstallSnapshot_Request) ProtoMessage()               {}
func (*InstallSnapshot_Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *InstallSnapshot_Request) GetServerId() uint64 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *InstallSnapshot_Request) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *InstallSnapshot_Request) GetLastSnapshotIndex() uint64 {
	if m != nil {
		return m.LastSnapshotIndex
	}
	return 0
}

func (m *InstallSnapshot_Request) GetByteOffset() uint64 {
	if m != nil {
		return m.ByteOffset
	}
	return 0
}

func (m *InstallSnapshot_Request) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *InstallSnapshot_Request) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *InstallSnapshot_Request) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type InstallSnapshot_Response struct {
	// *
	// Callee's term, for the caller to update itself.
	Term uint64 `protobuf:"varint,1,opt,name=term" json:"term,omitempty"`
	// *
	// The total number of bytes in the snapshot that the follower has
	// stored (after applying the request).
	//
	// This was introduced to fix
	// https://github.com/logcabin/logcabin/issues/174 .
	// Before, followers could only receive snapshot chunks in sequence. If
	// they restarted, they'd have discarded their previous chunks and they
	// would just repeatedly PANIC. This is now used to signal to the
	// leader how many bytes the follower actually has saved. The leader
	// considers the snapshot transfer complete when bytes_stored equals
	// the full size of the snapshot. The leader should use bytes_stored
	// as the value for byte_offset in the next request (most importantly,
	// when a follower reboots, it returns 0 here and the leader starts at
	// offset 0 in the next request).
	//
	// Leaders that do not support InstallSnapshot version 2 entirely
	// ignore this field.
	BytesStored uint64 `protobuf:"varint,2,opt,name=bytes_stored,json=bytesStored" json:"bytes_stored,omitempty"`
}

func (m *InstallSnapshot_Response) Reset()                    { *m = InstallSnapshot_Response{} }
func (m *InstallSnapshot_Response) String() string            { return proto.CompactTextString(m) }
func (*InstallSnapshot_Response) ProtoMessage()               {}
func (*InstallSnapshot_Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 1} }

func (m *InstallSnapshot_Response) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *InstallSnapshot_Response) GetBytesStored() uint64 {
	if m != nil {
		return m.BytesStored
	}
	return 0
}

func init() {
	proto.RegisterType((*Error)(nil), "RaftProtocol.Error")
	proto.RegisterType((*Server)(nil), "RaftProtocol.Server")
	proto.RegisterType((*SimpleConfiguration)(nil), "RaftProtocol.SimpleConfiguration")
	proto.RegisterType((*Configuration)(nil), "RaftProtocol.Configuration")
	proto.RegisterType((*Entry)(nil), "RaftProtocol.Entry")
	proto.RegisterType((*RequestVote)(nil), "RaftProtocol.RequestVote")
	proto.RegisterType((*RequestVote_Request)(nil), "RaftProtocol.RequestVote.Request")
	proto.RegisterType((*RequestVote_Response)(nil), "RaftProtocol.RequestVote.Response")
	proto.RegisterType((*AppendEntries)(nil), "RaftProtocol.AppendEntries")
	proto.RegisterType((*AppendEntries_Request)(nil), "RaftProtocol.AppendEntries.Request")
	proto.RegisterType((*AppendEntries_Response)(nil), "RaftProtocol.AppendEntries.Response")
	proto.RegisterType((*AppendEntries_Response_ServerCapabilities)(nil), "RaftProtocol.AppendEntries.Response.ServerCapabilities")
	proto.RegisterType((*InstallSnapshot)(nil), "RaftProtocol.InstallSnapshot")
	proto.RegisterType((*InstallSnapshot_Request)(nil), "RaftProtocol.InstallSnapshot.Request")
	proto.RegisterType((*InstallSnapshot_Response)(nil), "RaftProtocol.InstallSnapshot.Response")
	proto.RegisterEnum("RaftProtocol.OpCode", OpCode_name, OpCode_value)
	proto.RegisterEnum("RaftProtocol.EntryType", EntryType_name, EntryType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RaftService service

type RaftServiceClient interface {
	AppendEntries(ctx context.Context, in *AppendEntries_Request, opts ...grpc.CallOption) (*AppendEntries_Response, error)
	RequestVote(ctx context.Context, in *RequestVote_Request, opts ...grpc.CallOption) (*RequestVote_Response, error)
}

type raftServiceClient struct {
	cc *grpc.ClientConn
}

func NewRaftServiceClient(cc *grpc.ClientConn) RaftServiceClient {
	return &raftServiceClient{cc}
}

func (c *raftServiceClient) AppendEntries(ctx context.Context, in *AppendEntries_Request, opts ...grpc.CallOption) (*AppendEntries_Response, error) {
	out := new(AppendEntries_Response)
	err := grpc.Invoke(ctx, "/RaftProtocol.RaftService/AppendEntries", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) RequestVote(ctx context.Context, in *RequestVote_Request, opts ...grpc.CallOption) (*RequestVote_Response, error) {
	out := new(RequestVote_Response)
	err := grpc.Invoke(ctx, "/RaftProtocol.RaftService/RequestVote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RaftService service

type RaftServiceServer interface {
	AppendEntries(context.Context, *AppendEntries_Request) (*AppendEntries_Response, error)
	RequestVote(context.Context, *RequestVote_Request) (*RequestVote_Response, error)
}

func RegisterRaftServiceServer(s *grpc.Server, srv RaftServiceServer) {
	s.RegisterService(&_RaftService_serviceDesc, srv)
}

func _RaftService_AppendEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendEntries_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).AppendEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/RaftProtocol.RaftService/AppendEntries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).AppendEntries(ctx, req.(*AppendEntries_Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVote_Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).RequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/RaftProtocol.RaftService/RequestVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).RequestVote(ctx, req.(*RequestVote_Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _RaftService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "RaftProtocol.RaftService",
	HandlerType: (*RaftServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AppendEntries",
			Handler:    _RaftService_AppendEntries_Handler,
		},
		{
			MethodName: "RequestVote",
			Handler:    _RaftService_RequestVote_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/raft.proto",
}

func init() { proto.RegisterFile("proto/raft.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 886 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xcd, 0x6e, 0xeb, 0x44,
	0x14, 0xae, 0xf3, 0xdf, 0x93, 0xa4, 0xb8, 0xd3, 0x22, 0xac, 0x5c, 0xa4, 0xdb, 0xfa, 0x76, 0x51,
	0x5d, 0x44, 0x90, 0xca, 0x82, 0x25, 0xb2, 0x52, 0x03, 0x11, 0xc5, 0x0e, 0x63, 0xb7, 0x6c, 0x90,
	0xac, 0x69, 0x3c, 0x49, 0xad, 0x6b, 0x7b, 0x8c, 0x67, 0x72, 0xd5, 0xee, 0x79, 0x14, 0x1e, 0x00,
	0x89, 0x47, 0x60, 0xcd, 0x16, 0xf1, 0x02, 0xf0, 0x12, 0x6c, 0xd0, 0x8c, 0xed, 0x34, 0x6e, 0xaa,
	0xf6, 0xa2, 0xbb, 0x3b, 0xf3, 0xcd, 0x37, 0xdf, 0x9c, 0x73, 0xe6, 0xf3, 0x31, 0xe8, 0x59, 0xce,
	0x04, 0xfb, 0x2c, 0x27, 0x0b, 0x31, 0x56, 0x21, 0x1a, 0x60, 0xb2, 0x10, 0x33, 0x19, 0xce, 0x59,
	0x6c, 0x76, 0xa1, 0x6d, 0xe7, 0x39, 0xcb, 0xcd, 0x09, 0x74, 0x3c, 0x9a, 0xbf, 0xa5, 0x39, 0x7a,
	0x01, 0xbb, 0x5c, 0x45, 0x41, 0x14, 0x1a, 0xda, 0x91, 0x76, 0xda, 0xc2, 0xbd, 0x02, 0x98, 0x86,
	0xe8, 0x63, 0xd8, 0x25, 0x61, 0x98, 0x53, 0xce, 0x29, 0x37, 0x1a, 0x47, 0xda, 0xe9, 0x2e, 0xbe,
	0x07, 0x4c, 0x1b, 0x0e, 0xbc, 0x28, 0xc9, 0x62, 0x3a, 0x61, 0xe9, 0x22, 0x5a, 0xae, 0x72, 0x22,
	0x22, 0x96, 0xa2, 0x31, 0x74, 0x0b, 0x01, 0x6e, 0x68, 0x47, 0xcd, 0xd3, 0xfe, 0xd9, 0xe1, 0x78,
	0x33, 0x89, 0x71, 0x71, 0x31, 0xae, 0x48, 0xe6, 0x6f, 0x1a, 0x0c, 0xeb, 0x0a, 0x33, 0x40, 0x59,
	0x4e, 0xdf, 0x06, 0xf3, 0x4d, 0x54, 0x25, 0xd7, 0x3f, 0x3b, 0x7e, 0x20, 0xb6, 0x9d, 0x00, 0xde,
	0x97, 0x87, 0xb7, 0x14, 0x53, 0x7a, 0x2b, 0x1e, 0x28, 0x36, 0xde, 0x59, 0x51, 0x1e, 0xae, 0x41,
	0xe6, 0x5f, 0x1a, 0xb4, 0xed, 0x54, 0xe4, 0x77, 0x08, 0x41, 0x4b, 0xd0, 0x3c, 0x29, 0x9b, 0xa7,
	0x62, 0x74, 0x08, 0xed, 0x28, 0x0d, 0xe9, 0xad, 0xd1, 0x56, 0x60, 0xb1, 0x40, 0xc7, 0x30, 0x98,
	0xc7, 0x2b, 0x2e, 0x68, 0x1e, 0x88, 0x28, 0xa1, 0x46, 0x47, 0x6d, 0xf6, 0x4b, 0xcc, 0x8f, 0x12,
	0x8a, 0x3e, 0x81, 0x96, 0xb8, 0xcb, 0xa8, 0x4a, 0x6d, 0xef, 0xec, 0xa3, 0x7a, 0x6a, 0xea, 0x3e,
	0xff, 0x2e, 0xa3, 0x58, 0x91, 0x90, 0x05, 0xc3, 0x7a, 0x41, 0x4d, 0x55, 0xd0, 0x8b, 0xfa, 0xa9,
	0x7a, 0x29, 0xf5, 0x13, 0x32, 0xf9, 0x90, 0x08, 0x62, 0xb4, 0x8e, 0xb4, 0xd3, 0x01, 0x56, 0xb1,
	0xf9, 0xb7, 0x06, 0x7d, 0x4c, 0x7f, 0x5a, 0x51, 0x2e, 0xae, 0x98, 0xa0, 0xa3, 0x9f, 0x35, 0xe8,
	0x96, 0xeb, 0xa7, 0xed, 0x52, 0x75, 0xa2, 0xb1, 0xd1, 0x09, 0x13, 0x86, 0x31, 0xe1, 0x22, 0x88,
	0xd9, 0x32, 0x50, 0x9b, 0xcd, 0xa2, 0x68, 0x09, 0x5e, 0xb0, 0xa5, 0x2f, 0x39, 0x27, 0xb0, 0xb7,
	0xe6, 0x14, 0x6d, 0x6b, 0x29, 0xd2, 0xa0, 0x24, 0x4d, 0x25, 0x36, 0x72, 0xa1, 0x87, 0x29, 0xcf,
	0x58, 0xca, 0xe9, 0xa3, 0x3d, 0x37, 0xa0, 0xbb, 0xcc, 0x49, 0x2a, 0x68, 0xa8, 0x12, 0xe8, 0xe1,
	0x6a, 0x89, 0x3e, 0x84, 0x8e, 0x94, 0x66, 0x6f, 0xd4, 0xe5, 0x3d, 0xdc, 0x8e, 0xd9, 0xd2, 0x7d,
	0x63, 0xfe, 0xd3, 0x82, 0xa1, 0x95, 0x65, 0x34, 0x0d, 0x65, 0x63, 0x23, 0xca, 0x47, 0x7f, 0xbe,
	0x4f, 0xa5, 0x27, 0xb0, 0xa7, 0x5c, 0x7b, 0x5f, 0x45, 0x51, 0xea, 0x40, 0xa2, 0x55, 0x15, 0xb2,
	0x1f, 0x6b, 0x96, 0x92, 0x28, 0x4a, 0xed, 0x97, 0x24, 0xd5, 0x8f, 0x4f, 0xa1, 0x4b, 0x8b, 0x8c,
	0x8c, 0xb6, 0xfa, 0x82, 0x0e, 0x1e, 0xf1, 0x01, 0xae, 0x38, 0xca, 0x56, 0x2c, 0x49, 0x22, 0x51,
	0x5e, 0x5b, 0xd9, 0x4a, 0x61, 0x45, 0xef, 0xfe, 0x6d, 0x3c, 0xdf, 0x3c, 0xbe, 0x9a, 0xcf, 0x29,
	0xe7, 0x55, 0xf3, 0xca, 0xe5, 0x23, 0x8f, 0xd3, 0xdc, 0x7e, 0x1c, 0x74, 0x03, 0x07, 0x65, 0xb7,
	0xe6, 0x24, 0x23, 0xd7, 0x51, 0x1c, 0x09, 0x99, 0x7e, 0x4b, 0x19, 0xf2, 0x8b, 0x7a, 0xfa, 0xb5,
	0x9e, 0x8f, 0xab, 0xb4, 0xca, 0xb9, 0x30, 0xd9, 0x38, 0x8e, 0x11, 0xdf, 0xc2, 0x46, 0xbf, 0x6a,
	0x80, 0xb6, 0xa9, 0xe8, 0x02, 0x5e, 0x25, 0x51, 0x1a, 0xf0, 0x55, 0x96, 0xb1, 0x5c, 0xd0, 0x30,
	0xe0, 0x82, 0x08, 0x1a, 0x24, 0x64, 0x7e, 0x13, 0xa5, 0x34, 0x90, 0x93, 0xa6, 0x1a, 0x22, 0x43,
	0xfc, 0x32, 0x89, 0x52, 0xaf, 0x62, 0x7a, 0x92, 0xf8, 0x5d, 0xc1, 0xbb, 0x2a, 0x68, 0x4a, 0x8d,
	0xdc, 0x3e, 0xab, 0xd6, 0x28, 0xd5, 0xc8, 0xed, 0x53, 0x6a, 0xe6, 0x2f, 0x0d, 0xf8, 0x60, 0x9a,
	0x72, 0x41, 0xe2, 0xd8, 0x4b, 0x49, 0xc6, 0x6f, 0x98, 0x18, 0xfd, 0xf1, 0x7f, 0xad, 0xd6, 0xdc,
	0x78, 0xad, 0x31, 0x1c, 0xa8, 0x37, 0xe1, 0xa5, 0x5a, 0xed, 0xab, 0xd9, 0x97, 0x5b, 0xd5, 0x3d,
	0xc5, 0xeb, 0xbc, 0x84, 0xfe, 0xf5, 0x9d, 0xa0, 0x01, 0x5b, 0x2c, 0x38, 0x15, 0xe5, 0x50, 0x02,
	0x09, 0xb9, 0x0a, 0x59, 0x8f, 0x81, 0xce, 0xfd, 0x18, 0x50, 0x18, 0x4b, 0xa9, 0xd1, 0x55, 0x7e,
	0x50, 0xb1, 0xb4, 0x49, 0x55, 0x7b, 0x4f, 0xd5, 0x5e, 0x2d, 0x47, 0xd6, 0x33, 0x06, 0x3b, 0x86,
	0x81, 0xbc, 0x8f, 0x07, 0x5c, 0xb0, 0xbc, 0xfc, 0x44, 0x5b, 0x58, 0xa5, 0xc5, 0x3d, 0x05, 0xbd,
	0x3e, 0x87, 0x8e, 0x9b, 0x4d, 0x58, 0x48, 0x91, 0x0e, 0x03, 0x6c, 0x7f, 0x7f, 0x69, 0x7b, 0x7e,
	0x70, 0xe5, 0xfa, 0xb6, 0xbe, 0x83, 0x10, 0xec, 0x59, 0xb3, 0x99, 0xed, 0x9c, 0x07, 0xb6, 0xe3,
	0xe3, 0xa9, 0xed, 0xe9, 0x1a, 0x3a, 0x04, 0x7d, 0xea, 0x78, 0xbe, 0x75, 0x71, 0x11, 0x78, 0x8e,
	0x35, 0xf3, 0xbe, 0x71, 0x7d, 0xbd, 0xf1, 0xfa, 0x4b, 0xd8, 0x5d, 0xcf, 0x49, 0xd4, 0x87, 0xee,
	0xa5, 0xf3, 0xad, 0xe3, 0xfe, 0xe0, 0xe8, 0x3b, 0x68, 0x1f, 0x86, 0x13, 0xd7, 0xf9, 0x6a, 0xfa,
	0xf5, 0x25, 0xb6, 0xfc, 0xa9, 0xeb, 0xe8, 0x1a, 0xea, 0x41, 0xeb, 0xdc, 0xf2, 0x2d, 0xbd, 0x21,
	0x23, 0xc7, 0x75, 0x67, 0x7a, 0xf3, 0xec, 0x77, 0x39, 0xfe, 0xc8, 0x42, 0x48, 0x93, 0x45, 0x73,
	0x8a, 0x7e, 0x7c, 0x30, 0x25, 0xd0, 0xab, 0xa7, 0xed, 0xac, 0xde, 0x74, 0x74, 0xf2, 0x2e, 0x9e,
	0x37, 0x77, 0xd0, 0x55, 0x6d, 0xd6, 0xa2, 0x07, 0x3f, 0xa3, 0x8d, 0xad, 0xb5, 0xb2, 0xf9, 0x14,
	0xa5, 0xd2, 0xbd, 0xee, 0xa8, 0xff, 0xff, 0xe7, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0xab, 0x1b,
	0x16, 0x90, 0x13, 0x08, 0x00, 0x00,
}
